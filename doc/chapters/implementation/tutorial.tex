\subsection{JPA: Tutorial and Implementation}

JPA is a Java API specification for relational data management in applications.
JPA defines a standard way for simplifying database programming defining Java
Persistence Query Language (JPQL) which is an object-oriented query language
that operates against Java objects rather than directly with database tables.

JPA is Java standard specification for ORM (Object Relational Mapping), a
programming technique for the integration of object-oriented software with
RDBMS: with JPA a class (an Entity) represents a table stored in a database, an
instance of a class represents a row in the table and a member of an instance
represents a column.

There are various implementations of JPA\@. In this tutorial the Hibernate
implementation will be adopted.

In this tutorial we will show a simple implementation of JPA with Hibernate
using the database of Figure~\ref{fig:er} as reference.

\subsubsection{Configuration of JPA with Hibernate}

If using Maven as dependency manager, in order to use JPA with Hibernate you
must add the dependency in the POM file, in particular:

\lstinputlisting[language=XML, label={lst:pomhibernate},
style=xmlcode,caption={Hibernate dependency for Maven POM
file.}]{pomhibernate.xml}

Furthermore the file \code{persistence.xml} must be created.

The \code{persistence.xml} file must be placed in the folder
\code{src/main/re\-sources/META-INF}. This file (shown in
Listing~\ref{lst:persistence}) is a standard configuration file. Its purpose is
to provide the \code{EntityManager} with the information necessary to
save/update/query the database and configure the mapping layer. The file defines
the persistence-units, groups of persistent classes with their settings,
providing them with a unique identifier that can be used by the application.

\lstinputlisting[language=XML, label={lst:persistence}, style=xmlcode,
caption={\code{persistence.xml}}]{persistence.xml}

\subsubsection{Entity and Relationship}

\paragraph{Entity}

The first step is to define the entities, \idest*{the classes that map the
relational database tables}.

In this case we preferred to define a super class \code{Entity} from which to
derive the child classes \code{User}, \code{Restaurant} and \code{Reservation}.

\lstinputlisting[language=Java, label={lst:entity},
caption={\code{Entity\_.java}}]{Entity_.java}

Then we define the three classes that represent the tables of our database.

The class structure is shown below.

\lstinputlisting[language=Java, label={lst:user},
caption={\code{User\_.java}}]{User_.java}

\lstinputlisting[language=Java, label={lst:restaurant},
caption={\code{Restaurant\_.java}}]{Restaurant_.java}

\lstinputlisting[language=Java, label={lst:reservation},
caption={\code{Reservation\_.java}}]{Reservation_.java}

\paragraph{One-to-one Relationships}

In our case a one-to-one relationship is between a user and a restaurant. In
fact, a restaurant is owned by a user. So the one-to-one relationship is defined
in the \code{User} and \code{Restaurant} classes as follows:

\lstinputlisting[language=Java, label={lst:restauranto2o},
caption={One-to-one relationship in \code{Restaurant\_.java}}]{Restaurant_o2o.java}

\lstinputlisting[language=Java, label={lst:usero2o},
caption={One-to-one relationship in \code{User\_.java}}]{User_o2o.java}

%TODO: clarify
Unlike \code{Restaurant}, in the annotation \code{@OneToOne} in the \code{User}
class we specified the attribute \code{mappedBy}, in fact a bidirectional
relationship brings with it the concept of ``owner side'' and ``reverse side''.
Owner is the \code{Entity} whose report annotation (\code{@OneToOne}) does not
specify the \code{mappedBy}.  In essence, for a bidirectional relationship it is
always the entity linked to the table that holds the relational constraint of
foreign keys.

The reverse side indicates exactly this information (``I am not the Owner, look
at the other the indicated entity'') by inserting in the attribute mappedBy the
name of the relation field in the opposite entity (owner of the Entity
Restaurant).

\paragraph{One-to-many / Many-to-one Relationships}

This type of relationship is usually modeled with a foreign key from one table
to another so that different records in one table can reference the same record
in the other. In our case we have a user or a restaurant that can make multiple
reservations.

\lstinputlisting[language=Java, label={lst:usero2m},
caption={One-to-many relationship in \code{User\_.java}}]{User_o2m.java}
\lstinputlisting[language=Java, label={lst:restauranto2m},
caption={One-to-many relationship in \code{Restaurant\_.java}}]{Restaurant_o2m.java}
\lstinputlisting[language=Java, label={lst:reservationm2o},
caption={Many-to-one relationship in \code{Reservation\_.java}}]{Reservation_m2o.java}

Also in this case we use \code{@JoinColumn} (with \code{@ManytoOne}) to specify
the \code{Reservation}'s columns that hold the foreign keys of User and
Restaurant respectively.

In the \code{User} and \code{Restaurant} classes we use \code{@OneToMany} with
the \code{mappedBy} attribute to define in which field the relationship with
Reservation occurs.

\paragraph{Many-to-many Relationships}

There is also a \code{@ManyToMany} annotation that can be used to represent
many-to-many relationships. This annotation is used in conjunction with the
\code{@JoinTable} annotation that specifies the name of the table used for the
relationship along with the join columns:

\lstinputlisting[language=Java, label={lst:m2m}, caption={Many-to-many
annotations}]{m2m.java}

\subsubsection{EntityManager}

JPA also defines an \code{EntityManager}, whose purpose is the runtime
management of queries and transactions on persistent objects.

An \code{EntityManager} instance is associated with a persistence context, and
it is used to interact with the database. A persistence context is a set of
entity instances, which are actually the objects or instances of the model
classes.

The \code{EntityManager} is used to manage entity instances and their life
cycle, such as create entities, entities, remove entities, find and query
entities.

An \code{EntityManager} instance can be created as described below, using
\code{EntityManagerFactory}.

\lstinputlisting[language=Java, label={lst:em},
caption={\code{EntityManager.java}}]{EntityManager.java}

The class shown in Listing~\ref{lst:em} is a wrapper class for the Hibernate's
\code{EntityManager}. In our example we have created three
\code{EntityManager}'s child classes for each entity of our system:
\code{UserManager}, \code{RestaurantManager} and \code{ReservationManager}.

\subsubsection{CRUD Operations}

Whenever you want to manipulate data with JPA within an \code{EntityManager} you
must perform the following operations (except read operation, that does not
require to open a transaction):

\begin{enumerate}
	\item Begin a transaction.
	\item Manage entity instances (create, update, remove etc).
	\item Commit the transaction.
\end{enumerate}

How to begin and commit a transition is shown below:

\lstinputlisting[language=Java, label={lst:begin},
caption={Begin a transaction.}]{begin.java}

\lstinputlisting[language=Java, label={lst:commit},
caption={Commit a transaction.}]{commit.java}

In the following listings are shown the four CRUD operations applied to the
entities defined above:

\lstinputlisting[language=Java, label={lst:create},
caption={Create}]{create.java}

\lstinputlisting[language=Java, label={lst:read},
caption={Read}]{read.java}

\lstinputlisting[language=Java, label={lst:update},
caption={Update}]{update.java}

\lstinputlisting[language=Java, label={lst:delete},
caption={Delete}]{delete.java}

\subsubsection{Build Custom Queries}

JPA provides \standout{Criteria API}, an alternative way for defining JPA
queries, which is mainly useful for building dynamic queries with user-provided
parameters. In particular, we will see \code{CriteriaBuilder}.

\code{CriteriaBuilder} is used to construct criteria queries, compound
selections, expressions, predicates, orderings. An example of use is shown
below considering the \code{User} entity of this tutorial. In particular, we
want to find a user by searching for him through his \code{username} (and not
through his \code{Id} as the \code{find} method allows).

\lstinputlisting[language=Java, label={lst:criteria},
caption={\code{CriteriaBuilder} example.}]{criteria.java}
